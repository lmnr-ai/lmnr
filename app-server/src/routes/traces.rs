
use super::ResponseResult;
use crate::db::{
    self,
    events::EventWithTemplateName,
    modifiers::{DateRange, Filter},
    trace::{Span, SpanPreview, Trace, TraceWithEvents},
    DB,
};
use actix_web::{get, web, HttpResponse};
use serde::{Deserialize, Serialize};
use serde_json::Value;
use uuid::Uuid;

const DEFAULT_PAGE_SIZE: usize = 50;


#[derive(Deserialize, Debug)]
#[serde(rename_all = "camelCase")]
struct GetTracesQueryParams {
    /// page number starting from 0
    #[serde(default)]
    page_number: usize,
    page_size: Option<usize>,
    #[serde(default)]
    filter: Value,
    #[serde(default)]
    #[serde(flatten)]
    pub date_range: Option<DateRange>,
}

#[derive(Serialize)]
#[serde(rename_all = "camelCase")]
struct GetTracesResponse {
    total_entries: i64,
    traces: Vec<TraceWithEvents>,
}

/// Get traces generated by Laminar tracing
#[get("traces")]
pub async fn get_traces(
    path: web::Path<Uuid>,
    db: web::Data<DB>,
    query_params: web::Query<GetTracesQueryParams>,
) -> ResponseResult {
    let project_id = path.into_inner();
    let query_params = query_params.into_inner();
    let limit = query_params.page_size.unwrap_or(DEFAULT_PAGE_SIZE);
    let offset = limit * (query_params.page_number);
    let filters = Filter::from_url_params(query_params.filter);
    let date_range = query_params.date_range;

    let traces = db::trace::get_traces(
        &db.pool,
        project_id,
        limit,
        offset,
        filters.clone(),
        date_range.as_ref(),
    )
    .await?;
    let total_entries =
        db::trace::count_traces(&db.pool, project_id, filters, date_range.as_ref()).await?;
    let response = GetTracesResponse {
        total_entries,
        traces,
    };

    Ok(HttpResponse::Ok().json(response))
}

#[derive(Serialize)]
#[serde(rename_all = "camelCase")]
pub struct TraceWithSpanPreviews {
    #[serde(flatten)]
    pub trace: Trace,
    pub spans: Vec<SpanPreview>,
}

/// Get a single trace generated by Laminar tracing instrumentation
#[get("traces/{trace_id}")]
pub async fn get_single_trace(
    params: web::Path<(Uuid, Uuid)>,
    db: web::Data<DB>,
) -> ResponseResult {
    let (_project_id, trace_id) = params.into_inner();

    let trace = db::trace::get_single_trace(&db.pool, trace_id).await?;
    let span_previews = db::trace::get_span_previews(&db.pool, trace_id).await?;

    let trace_with_spans = TraceWithSpanPreviews {
        trace,
        spans: span_previews,
    };

    Ok(HttpResponse::Ok().json(trace_with_spans))
}

#[derive(Serialize)]
#[serde(rename_all = "camelCase")]
pub struct SpanWithEvents {
    #[serde(flatten)]
    pub span: Span,
    pub events: Vec<EventWithTemplateName>,
}

/// Get a single span generated by Laminar tracing instrumentation
/// TODO: Maybe change path to /traces/{trace_id}/spans/{span_id} or smth like that
#[get("spans/{span_id}")]
pub async fn get_single_span(params: web::Path<(Uuid, Uuid)>, db: web::Data<DB>) -> ResponseResult {
    let (_project_id, span_id) = params.into_inner();

    let span = db::trace::get_single_span(&db.pool, span_id).await?;
    let events = db::events::get_events_for_span(&db.pool, span_id).await?;

    let span_with_events = SpanWithEvents { span, events };

    Ok(HttpResponse::Ok().json(span_with_events))
}
